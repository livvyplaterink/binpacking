#this file executes the heuristic: orders the items and bins, places the items in the bins, and then performs a postprocessing step
#before running this file, you need to run test.py to generate the bin_objects list and the item_objects list or you need to define them at the top of this script 

from sorting_objects import *
from operator import attrgetter
import random
from item_bin2 import *
import sys 


#bins and items are generated by test.py 

#calculating cost/volume ratio for each bin 
for b in bin_objects:
    b.cv_ratio = b.cost / b.volume

#ordering bins in K according to non-decreasing order of the ratio c_j/V_j and non-decreasing order of V_j when the cost ratios c_j/V_j are equal
ordered_bins = multisort(bin_objects, (('cv_ratio', False), ('volume', False)))

#ordering items in I according to non-increasing order of volume
ordered_items = sorted(item_objects, key = attrgetter('volume'), reverse = True)

#ordered_items = [items('i43', 100), items('i52', 100), items('i61', 97), items('i59', 96), items('i50', 95), items('i10', 94), items('i16', 93), items('i38', 91), items('i14', 90), items('i76', 88), items('i66', 87), items('i23', 86), items('i45', 78), items('i70', 78), items('i56', 77), items('i8', 76), items('i29', 75), items('i68', 74), items('i34', 69), items('i42', 68), items('i41', 67), items('i11', 65), items('i26', 64), items('i53', 63), items('i12', 61), items('i69', 61), items('i44', 58), items('i1', 57), items('i47', 57), items('i39', 56), items('i13', 54), items('i6', 51), items('i40', 49), items('i65', 49), items('i79', 47), items('i7', 46), items('i3', 44), items('i62', 44), items('i17', 43), items('i54', 40), items('i73', 38), items('i75', 38), items('i22', 37), items('i72', 37), items('i4', 36), items('i55', 36), items('i9', 34), items('i15', 34), items('i37', 33), items('i19', 32), items('i20', 31), items('i49', 31), items('i78', 31), items('i58', 30), items('i18', 29), items('i35', 29), items('i24', 27), items('i2', 26), items('i46', 26), items('i67', 26), items('i48', 25), items('i80', 25), items('i5', 21), items('i32', 20), items('i36', 18), items('i74', 17), items('i30', 16), items('i64', 16), items('i25', 14), items('i57', 14), items('i33', 13), items('i63', 12), items('i31', 11), items('i77', 11), items('i28', 10), items('i60', 10), items('i51', 9), items('i71', 7), items('i21', 6), items('i27', 3), ]


#defining filled bins list 
filled_bins = []

#placing items in bins
for i in ordered_items:
    #if S is empty, put the largest item i into the first bin in K that accomodates i
    if len(filled_bins) == 0: 
        for l in ordered_bins:
            print("i: " + str(i.name))
            print("l: " + str(l.name))
            if i.volume > l.remaining_volume:
                continue
            print("item volume: " + str(i.volume))
            print("bin volume: " + str(l.remaining_volume))
            print("item " + str(i.name) + " of volume " + str(i.volume) + " fits in bin " + str(l.name) + " with volume " + str(l.remaining_volume))
            filled_bins.append(l)
            l.items_contained.append(i)
            l.remaining_volume -= i.volume
            #ordering bins in S according to non-decreasing order of remaining volume and non-decreasing order of c_j/V_j when the remaining volumes are equal
            filled_bins = multisort(filled_bins, (('remaining_volume', False), ('cv_ratio', False)))
            print(filled_bins)
            break
    else: 
        #if S is not empty, and if i can be accomodated into a bin in S, then place it into the bin into the first bin in S that can accomodate i
        for b in filled_bins: 
            print("i: " + str(i.name))
            print("b: " + str(b.name))
            print("item volume: " + str(i.volume))
            print("bin volume: " + str(b.remaining_volume))
            if i.volume <= b.remaining_volume: 
                print("item " + str(i.name) + " of volume " + str(i.volume) + " fits in bin " + str(b.name) + " with remaining volume " + str(b.remaining_volume))
                b.items_contained.append(i)
                b.remaining_volume -= i.volume
                filled_bins = multisort(filled_bins, (('remaining_volume', False), ('cv_ratio', False)))
                print(filled_bins)
                break 
            #if S is not empty and if i cannot be accomodated into a bin in S, then place it into the first bin in K that can accommodate i
            if b == filled_bins[len(filled_bins)-1]: 
                if i.volume > b.remaining_volume: 
                    print("item " + str(i.name) + " of volume " + str(i.volume) + " too large for bin " + str(b.name) + " with remaining volume " + str(b.remaining_volume))
                    for j in ordered_bins: 
                        print("i: " + str(i.name))
                        print("j: " + str(j.name))
                        print("item volume: " + str(i.volume))
                        print("new bin volume: " + str(j.remaining_volume))
                        if j in filled_bins:
                            print(str(j.name) + " is in filled bins")
                            continue
                        if i.volume > j.remaining_volume: 
                            print("item " + str(i.name) + " of volume " + str(i.volume) + " too large for new bin " + str(j.name) + " with remaining volume " + str(j.remaining_volume))
                            continue
                        print("item " + str(i.name) + " of volume " + str(i.volume) + " fits in new bin " + str(j.name) + " with remaining volume " + str(j.remaining_volume))
                        filled_bins.append(j)
                        j.items_contained.append(i)
                        j.remaining_volume -= i.volume 
                        #ordering bins in S according to non-decreasing order of remaining volume and non-decreasing order of c_j/V_j when the remaining volumes are equal
                        filled_bins = multisort(filled_bins, (('remaining_volume', False), ('cv_ratio', False)))
                        print(filled_bins)
                        break 
                    break

#ordering bins in S according to non-decreasing order of remaining volume and non-decreasing order of c_j/V_j when the remaining volumes are equal
filled_bins = multisort(filled_bins, (('remaining_volume', False), ('cv_ratio', False)))

#showing original cost before postprocessing step
cost1 = 0 
for b in filled_bins: 
    cost1+= b.cost 
print("cost after filling bins: " + str(cost1)) 

#defining unfilled bin set K\S
unfilled_bins = []
for j in ordered_bins: 
    if j not in filled_bins: 
        unfilled_bins.append(j) 

#ordering bins in K\S according to non-decreasing order of cost and non-increasing order of volume when costs are equal
unfilled_bins = multisort(unfilled_bins, (('cost', False), ('volume', True)))
print(unfilled_bins)
for n in range(len(filled_bins)):
    b = filled_bins[n]
    print(n)
    print(b.name)
    v_b = 0
    for i in b.items_contained:
        v_b += i.volume
    for k in unfilled_bins:
        print("unfilled bin: " + str(k.name) + " volume " + str(k.volume))
        print("filled bin: " + str(b.name) + " item volume " + str(v_b))
        print("filled bin: " + str(b.name) + " remaining volume " + str(b.remaining_volume))
        print("unfilled bin " + str(k.name) + " cost " + str(k.cost))
        print("filled bin: " + str(b.name) + " cost " + str(b.cost))
        if (k.volume >= v_b) and (k.cost < b.cost):
            k.items_contained = b.items_contained
            b.items_contained = []
            k.remaining_volume -= v_b
            b.remaining_volume = b.volume
            unfilled_bins.remove(k)
            unfilled_bins.append(b)
            filled_bins[n] = k
            unfilled_bins = multisort(unfilled_bins, (('cost', False), ('volume', True)))
            break


print("cost after filling bins: " + str(cost1))

cost = 0 
for b in filled_bins:
    cost += b.cost 
print("final cost: " + str(cost))

print(filled_bins) 

